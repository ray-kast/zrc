#!/usr/bin/env perl6
use v6;
use File::Directory::Tree;
use JSON::Fast;

multi sub say(Str :i($msg)) { say "\e[1m[AUR]\e[0;38;5;4m $msg\e[0m" }
multi sub say(Str :s($msg)) { say "\e[1m[AUR]\e[0;38;5;2m $msg\e[0m" }
multi sub say(Str :w($msg)) { say "\e[1m[AUR]\e[0;38;5;3m $msg\e[0m" }
multi sub say(Str :e($msg)) { say "\e[1;38;5;9m[AUR]\e[0;38;5;1m $msg\e[0m" }

multi sub die(Str :e($msg)) { say :e($msg); die $msg; }

sub yesno(Str $prompt, Bool $default) {
  loop {
    print "$prompt [{
      if $default { "Y/n" }
      else { "y/N" }
    }] ";

    given $*IN.get() andthen .chomp {
      when Empty { say ''; exit 1; }
      when /:i y/ | /:i yes/ { return True; }
      when /:i n/ | /:i no/ { return False; }
      when '' { return $default; }
      default { say :e("invalid input"); }
    }
  }
}

class DepsGraph {
  has SetHash %!gives{Pair};
  has SetHash %!deps{Pair};
  has Bool %!dangling{Pair};
  has SetHash $!ins;

  method nodes() { return %!deps.keys.grep((:node))».value; }
  method edges() { return %!deps.keys.grep((:edge))».value; }

  method ensure(Pair:D[Str:D,Str:D] $elem) {
    %!gives{$elem} = SetHash.new unless $elem ∈ %!gives;
    %!deps{$elem} = SetHash.new unless $elem ∈ %!deps;
  }

  multi method add(Str:D :$node) {
    die :e("node '$node' already in depsgraph") if %!dangling{:$node} === False;
    self.ensure: (:$node);
    %!dangling{:$node} = False;
  }

  multi method add(Str:D :$edge) {
    die :e("edge '$edge' already in depsgraph") if %!dangling{:$edge} === False;
    self.ensure: (:$edge);
    %!dangling{:$edge} = False;
    $!ins{:$edge} = !%!deps{:$edge}.elems;
  }

  multi method depend(Str:D :$node, Str:D :on-edge($edge)) {
    %!dangling{:$node} = True unless %!dangling{:$node}:exists;
    %!dangling{:$edge} = True unless %!dangling{:$edge}:exists;
    self.ensure: (:$node);
    self.ensure: (:$edge);
    ++%!gives{:$edge}{:$node};
    ++%!deps{:$node}{:$edge};
  }

  multi method depend(Str:D :$edge, Str:D :on-node($node)) {
    %!dangling{:$node} = True unless %!dangling{:$node}:exists;
    %!dangling{:$edge} = True unless %!dangling{:$edge}:exists;
    self.ensure: (:$node);
    self.ensure: (:$edge);
    ++%!gives{:$node}{:$edge};
    ++%!deps{:$edge}{:$node};
    $!ins{:$edge} = False;
  }

  method run() {
    die :e("dangling elements in depsgraph: %!dangling.grep({ .value }).map({ .key }).join(', ')") if %!dangling.values.any;

    my SetHash %deps = %!deps;

    my Pair @q = $!ins.keys;
    my SetHash $done;

    return gather {
      while @q.elems {
        my $edge = @q.shift;

        die :e("bad depsgraph edge: $edge") unless $edge.key ~~ 'edge';

        for %!gives{$edge}.keys -> $node {
          next if $done{$node};

          --%deps{$node}{$edge};

          unless %deps{$node}.elems {
            for %!gives{$node}.keys -> $edge2 {
              next if $done{$edge2};

              --%deps{$edge2}{$node};

              unless %deps{$edge2}.elems {
                @q.append($edge2);
                $done{$edge2} = True;
              }
            }
          }
        }

        take $edge.value;
      }
    }
  }
}

grammar PkgBuild-Grammar {
  rule TOP {^ <decl>* $}
  rule decl { <key> ｢=｣ <str>* }
  token key { <[a..zA..Z0..9_]>+ }
  token str { ｢'｣ <val> ｢'｣ }
  token val { [ <-[\\']> | \\. ]* }
}

class PkgBuild-Parse {
  has %!decls;
  method TOP ($/) { make %!decls; }
  method decl ($/) { %!decls{$<key>} = @($<str>.map({ .made }).List); }
  method str ($/) { make $<val>.made; }
  method val ($/) { make $/.subst(/ ｢\｣ )> ｢'｣ /, '', :g); }
}

sub pkgbuild-info(Str:D $pkg, Array[Str] $q, DepsGraph:D $graph) {
  say :i('reading PKGBUILD...');

  my $out = .out.slurp given run((flat <env -i bash -c>, q:to/END/), :out) or die :e('reading PKGBUILD failed');
  f=$(mktemp /tmp/aur_XXXXXX)
  compgen -v | sort >"$f"
  source ./PKGBUILD
  declare -a vars arr
  vars=$(comm -13 "$f" <(compgen -v | sort))
  for v in $vars; do
    echo -n "$v="
    eval arr=\(\"\${${v}[@]}\"\)
    for l in "${arr[@]}"; do
      echo -n "'$(sed -re "s/'/\\\\\&/g" <<<$l)'"
    done
    echo
  done
  rm "$f"
  END
  say $out.chomp;

  say :i('parsing info...');

  my %info = PkgBuild-Grammar.parse($out, :actions(PkgBuild-Parse.new)).made;

  my $nonopt-deps = set(«'' make check»
    .flatmap({ %info.keys.grep(/^ $_ 'depends' [｢_｣ \w .*]? $/); })
    .unique.flatmap({ @(%info{$_}) }));

  my $opt-deps = set(«opt»
    .flatmap({ %info.keys.grep(/^ $_ 'depends' [｢_｣ \w .*]? $/); })
    .unique.flatmap({ @(%info{$_}) }));

  my $alldeps = $nonopt-deps ∪ $opt-deps;

  my $wants = set(do run((flat <pacman -T>, $alldeps.keys), :out)
    andthen .out.lines.List
    orelse die :e("Dependency testing with pacman failed."));
  my $haves = $alldeps ∖ $wants;

  my $aur-wants = set($wants.keys.grep: { not run(«pacman -Si $_», :out('/dev/null'), :err('/dev/null')) });

  say "Base package: $_" with %info<pkgbase>;
  say "Package(s): $_.join(', ')" with %info<pkgname>;
  say "Belongs to: $_.join(', ')" with %info<groups>;
  with %info<pkgver> {
    say "Version: { %info<pkgver> // '<unknown>' }"
      ~ do { " ($_.join(', '))" if .elems } given (flat
        do { "release $_" with %info<pkgrel> },
        do { "epoch $_" with %info<epoch> }
      )
  }
  say "Architecture(s): $_.join(', ')" with %info<arch>;
  say "Description: $_" with %info<pkgdesc>;
  say "License: $_" with %info<license>;

  say "URL: $_" with %info<url>;

  #! TODO: Handle architecture-specific dependencies

  my $max-dep-len = $alldeps.keys.map({ .codes }).reduce(&[max]);

  sub dep-info(Str $dep, Str $suffix = Str) {
    say ' - '
      ~ sprintf("%-{ $max-dep-len }s", $dep)
      ~ ($suffix if $suffix)
      ~ (' [installed]' if $dep ∈ $haves)
      ~ (' [install from AUR]' if $dep ∈ $aur-wants)
  }

  say "\nDependencies:" if <depends optdepends>.map({ %info{$_} andthen .elems }).any;
  for %info<depends> andthen @$_ { dep-info($_) }
  for %info<optdepends> andthen @$_ { dep-info($_, ' (optional)') }
  say "\nBuild dependencies:" if %info<makedepends> andthen .elems;
  for %info<makedepends> andthen @$_ { dep-info($_) }
  say "\nCheck dependencies:" if %info<checkdepends> andthen .elems;
  for %info<checkdepends> andthen @$_ { dep-info($_) }

  return unless yesno('Install?', True);

  $graph.add(:edge($pkg));

  for |%info<pkgname> -> $node {
    $graph.add(:$node);
    $graph.depend(:$node, :on-edge($pkg));
  }

  for ($aur-wants ∩ $nonopt-deps).keys -> $on-node {
    $q.append($on-node);
    $graph.depend(:edge($pkg), :$on-node);
  }
}

## START

unless @*ARGS.elems {
  $*ERR.say: "Usage: aur <packages...>";

  exit 1;
}

chdir $*HOME.child: 'AUR';

mkdir $_ unless .e && .d given '.tmp'.IO;

my DepsGraph $graph = DepsGraph.new;
my Str @q = @*ARGS.List;

while @q.elems {
  my $arg = @q.shift;
  my $pkg = $arg.IO;

  say :i("installing package '$pkg'...");

  if $pkg.e {
    say "Folder '$pkg' already exists.";
    next unless yesno('Replace it?', True);
    unless rmtree $pkg { say :e("couldn't delete folder '$pkg'"); next; }
  }

  say :i('cloning git repository...');

  my $tmpdir = '.tmp'.IO.child: $pkg;

  rmtree $tmpdir if $tmpdir.e;

  run «git clone "https://aur.archlinux.org/$pkg.git" $tmpdir» or do { say :e("git clone failed"); next; };

  chdir $tmpdir;

  my $success = .out.slurp
    given run <git ls-files>, :out or do { say :e('git ls-files failed'); next; };

  chdir '../..'.IO;

  if $success {
    $tmpdir.rename: $pkg;
    chdir $pkg;

    pkgbuild-info($arg, $@q, $graph);

    LEAVE { chdir '..'.IO; }
  }
  else {
    say :e("package '$pkg' not found");

    rmtree $tmpdir if $tmpdir.e;
  }
}

my @edges = $graph.edges.List;

unless @edges.elems {
  say :i('nothing to install');
  exit;
}

say "Installing AUR packages:";

for @edges { say " - $_"; }

say "Resulting pacman packages:";

for $graph.nodes { say " - $_"; }

exit unless yesno('Continue with installation?', True);

for $graph.run -> $arg {
  my $pkg = $arg.IO;

  chdir $pkg;

  say :i("building '$pkg'...");

  if run <makepkg -si> { say :s("done!"); }
  else { say :e("makepkg failed"); }

  LEAVE { chdir '..'.IO; }
}
